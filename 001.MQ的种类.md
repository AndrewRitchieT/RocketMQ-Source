# MQ



## MQ的多种实现



### ZeroMQ

ØMQ （也拼写作ZeroMQ，0MQ或ZMQ)是一个为可伸缩的分布式或并发应用程序设计的高性能异步消息库。它提供一个消息队列, 但是与面向消息的中间件不同，ZeroMQ的运行不需要专门的消息代理（message broker）。该库设计成常见的套接字风格的API。

ZeroMQ是由iMatix公司和大量贡献者组成的社群共同开发的。

引用官方说法，“ZMQ(以下ZeroMQ简称ZMQ)是一个简单好用的传输层，像框架一样的一个socket library，他使得Socket编程更加简单、简洁和性能更高。是一个消息处理队列库，可在多个线程、内核和主机盒之间弹性伸缩。ZMQ的明确目标是“成为标准网络协议栈的一部分，之后进入Linux内核”。

ZeroMQ根本就不是一个消息队列服务器，更像是一组底层网络通讯库，对原有的Socket API加上一层封装，是我们操作更简便。使用时只需要引入相应的jar包即可。

ZeroMQ对于消息的处理可以说除却请求-应答模式之外，基本就是不关系消息是否丢失，它只管发送。



### **ActiveMQ** 

**单机吞吐量：**万级

**时效性：**ms 级

**可用性：**高，基于主从架构实现高可用性

**消息可靠性：**有较低的概率丢失数据

**功能支持：**MQ 领域的功能极其完备

**总结：**

1）非常成熟，功能强大，在早些年业内大量的公司以及项目中都有应用

2）偶尔会有较低概率丢失消息

 3）现在社区以及国内应用都越来越少，官方社区现在对 ActiveMQ 5.x 维护越来越

少，几个月才发布一个版本

 4）主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用



为什么activeMQ有较低概率丢失数据？

因为是异步的处理机制，并且没有持久化的机制。在主从架构下，master收到消息直接返回，有可能正在异步同步化给slave的时候宕机了，导致消息丢失。另外没有持久化的机制，未落盘的情况下宕机了。



主从架构的，异步落盘的，就有可能会发生数据丢失。CAP中AP模型会有数据丢失的问题





### **RabbitMQ** 

 **单机吞吐量：**万级

 **topic** **数量对吞吐量的影响：**

 **时效性：**微秒级，延时低是一大特点。

 **可用性：**高，基于主从架构实现高可用性

 **消息可靠性：** **功能支持：**基于 erlang 开发，所以并发能力很强，性能极其好，延时很低

 **总结：** 

 1）erlang 语言开发，性能极其好，延时很低；

 2）吐量到万级，MQ 功能比较完备

 3）开源提供的管理界面非常棒，用起来很好用

 4）社区相对比较活跃，几乎每个月都发布几个版本分

 5）在国内一些互联网公司近几年用 rabbitmq 也比较多一些 但是问题也是显而易见

的，RabbitMQ 确实吞吐量会低一些，这是因为他做的实现机制比较重。

 6）erlang 开发，很难去看懂源码，基本职能依赖于开源社区的快速维护和修复

bug。

 7）rabbitmq 集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是 erlang 语

言本身带来的问题。很难读源码，很难定制和掌控。







### **RocketMQ** 

 **单机吞吐量：**十万级

 **topic** **数量都吞吐量的影响：**topic 可以达到几百，几千个的级别，吞吐量

会有较小幅度的下降。可支持大量 topic 是一大优势。

 **时效性：**ms 级

 **可用性：**非常高，分布式架构

 **消息可靠性：**经过参数优化配置，消息可以做到 0 丢失。主机同步从机持久化，保证消息不丢失。

 **功能支持：**MQ 功能较为完善，还是分布式的，扩展性好

 **总结**

接口简单易用，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，

社区维护还可以，可靠性和可用性都是 ok 的，还可以支撑大规模的 topic 数量，支持复杂

**MQ 业务场景**

而且一个很大的优势在于，源码是 java，我们可以自己阅读源码，定制自己公司

的 MQ，可以掌控 3）社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这

块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码

相比于其他的 mq 消息中间件具有主要优势特性有：

支持事务型消息（消息发送和 DB 操作保持两方的最终一致性，rabbitmq 和 kafka 不支持），Rocketmq   独有的事务处理能力： 弱事务，无法回滚，最终一致性

支持结合 rocketmq 的多个系统之间数据最终一致性（多方事务，二方事务是前提）

支持 18 个级别的延迟消息（rabbitmq 和 kafka 不支持）

支持指定次数和时间间隔的失败消息重发（kafka 不支持，rabbitmq 需要手动确认）

支持 consumer 端 tag 过滤，减少不必要的网络传输（rabbitmq 和 kafka 不支持）

支持重复消费（rabbitmq 不支持，kafka 支持）







