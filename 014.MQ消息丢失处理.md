

消息丢失的几种情况分析



## 假设消息系统正在将消息发送至MQ

订单系统推送消息到RoketMQ过程中，网络连接发生问题，导致消息发送失败

MQ收到了消息，但是MQ的网络通信模块代码出现了异常，导致消息没有处理成功

写消息的时候，刚好遇到某个Leader Broker故障，Flower Broker正在切换为LeaderBroker



解决：

通过RocketMQ事务消息机制来保证生产者推送给Broker的消息一定会写入，不会半路丢失消息

在基于RocketMQ的事务消息机制中，首先生产者发送一条half消息到MQ去，这个half消息还不能被消费者所消费，如果half消息发送失败，则回滚生产者逻辑。如果half消息发送成功，则生产者正常执行本地逻辑。

假设生产者在之后的逻辑中更新数据失败了，则生产者发送rollback请求给MQ，要求MQ删除之前的half消息，生产者随后回滚本地业务逻辑。

假设生产者完成了本地事务操作，此时生产者发送commit请求给MQ，要求MQ对之前的half消息进行commit操作，让消费者可以消费这条消息。





假设生产者发送half消息给MQ，MQ保存下来了，但是MQ返回给我们的响应没有收到，生产者没收到响应，则回滚本地业务逻辑，MQ存储下来的half消息怎么处理？

假设生产者收到half消息写入成功的响应，业务逻辑也执行完毕，但是发送commit和rollback请求给MQ失败了，MQ存储下来的half消息怎么处理？

假设生产者收到half消息写入成功的响应，业务逻辑也执行完毕，但是发送commit和rollback请求给MQ后,MQ宕机了，MQ重启后对存储下来的half消息怎么处理？

RocketMQ有一个补偿逻辑，他会扫描自己处于half状态的消息，如果我们一直没有对这个消息执行commit/rollback操作，超过一定的时间，就会回调生产者的接口，询问该消息如何处理。重启后也会扫描half消息，执行补偿逻辑。















## 假设订单系统成功将消息写入MQ

Broker机器宕机，但此时消息还只是存在于oscache，还未来得及写入磁盘，内存数据丢失







## 假设订单消息已经成功写入MQ的broker磁盘中

磁盘故障，导致写入的数据丢失。







## 假设消息已经被消费者获取

假设消息已到达消费者内存中，但在消费者内存中还未开始消费逻辑处理，MQ的消费者有可能会自动提交已经消费的offset，那么如果此时消费者还没处理这个消息的情况下，消费者直接自动提交了这个消息1的offset的broker中，表示消费者已经成功处理offset1的消息，接着恰巧在这个时候，我们红包系统突然宕机或者重启，或者在逻辑处理时数据库更新失败，内存里的消息还未正式消费就丢失了，导致业务没有真正处理。





