

消息丢失的几种情况分析



## 1.假设消息系统正在将消息发送至MQ

订单系统推送消息到RoketMQ过程中，网络连接发生问题，导致消息发送失败

MQ收到了消息，但是MQ的网络通信模块代码出现了异常，导致消息没有处理成功

写消息的时候，刚好遇到某个Leader Broker故障，Flower Broker正在切换为LeaderBroker



![image-20200624095253141](images/image-20200624095253141.png)

解决方案

1.事务消息

![image-20200624095356135](images/image-20200624095356135.png)

2.同步+重试

![image-20200624095425355](images/image-20200624095425355.png)



## 2.假设订单系统成功将消息写入MQ

Broker机器宕机，但此时消息还只是存在于oscache，还未来得及写入磁盘，内存数据丢失

![image-20200624095634814](images/image-20200624095634814.png)

在实施1里的解决方案后，消息会保证投递到MQ。

但是确保消息写入了MQ，并不能保证消息不丢失



如何解决

同步刷盘：写入MQ的每条消息，，调整broker的配置文件，将flushDiskType配置设置为SYNC_FLUSH,默认他的值是ASYNC_FLUSH 即默认是异步刷盘。

同步刷盘写入MQ的消息肯定是写入了磁盘而不是oscache



## 3.假设订单消息已经成功写入MQ的broker磁盘中

磁盘故障，导致写入的数据丢失。





如何解决：

基于MQ的Dledger技术和Raft协议主从架构模式避免磁盘故障导致数据丢失

必须让一个masterBroker有一个SlaveBroker去同步他的数据，而且一条消息写入master成功，必须保证slaveBroker也写入成功，保证数据有多个副本



![image-20200624095056113](images/image-20200624095056113.png)



## 4.假设消息已经被消费者获取

假设消息已到达消费者内存中，但在消费者内存中还未开始消费逻辑处理，MQ的消费者有可能会自动提交已经消费的offset，那么如果此时消费者还没处理这个消息的情况下，消费者直接自动提交了这个消息1的offset的broker中，表示消费者已经成功处理offset1的消息，接着恰巧在这个时候，我们红包系统突然宕机或者重启，或者在逻辑处理时数据库更新失败，内存里的消息还未正式消费就丢失了，导致业务没有真正处理。



解决方案：

处理完消息后再手动提交offset+故障转移机制

![image-20200624102335175](images/image-20200624102335175.png)



RocketMQ的消费者会注册一个监听器，MessageListenerConcurrently这个东西，当消费者获取到一批消息后，就会回调监听器函数来处理消息。当消息处理完毕以后，就会返回消费成功的标志，ConsumerConcurrentlyStatus.CONSUME_SUCCESS，告诉MQ，这批消息已经处理完了，接着消费者提交这批消息的offset到broker

如果消息处理完毕，然后提交消息的offset到broker，此时消费者系统崩溃，是不会丢失消息的。

如果消费者获取到一批消息后，没处理完，并且没有返回ConsumeConcurrentStatus.CONSUME_SUCCESS这个状态，消费者系统崩溃，broker不会认为你已经处理完这批消息，它会把这批未处理的消息发送给其他消费者系统来处理。这种情况下，消息也是绝对不会丢的

要注意不能在代码中对消息进行异步的处理，用下图中的方法处理消息会导致子线程还没有处理完消息，就已经返回了offset信息。如果消费者系统宕机，就会导致消息丢失

![image-20200624132921112](images/image-20200624132921112.png)





零丢失方案总结：

1.发送消息到MQ的零丢失：

方案a: 同步发送消息+反复重试

方案b: 事务消息机制



2.MQ收到消息之后的零丢失：

开启同步刷盘策略+主从架构同步机制，只要让一个Broker收到消息后同步写入磁盘，同时同步复制给其他Broker，然后再返回响应给生产者写入成功，就可以保证MQ不会丢失消息



3.消费消息的零丢失

采用RocketMQ的消费者天然就可以保证处理完消息后，才会提交消息的offset到broker中。



消息零丢失的优势与劣势

2次请求+磁盘写入+主从同步+offset提交导致性能下降。





## 查找消息是否丢失



设置消息的key为一个唯一值，比如说 订单id

message.setKeys(orderId)

这个消息存储到broker上，会基于key构建hash索引，这个hash索引就存放在IdexFile索引文件里

后续我们通过MQ提供的命令去根据key查询这个消息，

mqadmin  queryMsgByKey -n  127.0.0.1:9876 -t SCANRECORD -k orderId 



如果mq彻底不可用了，通过写入本地磁盘来持久化，或者存入数据库暂存起来。降级方案。





